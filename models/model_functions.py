import numpy as np
import pandas as pd
import mne
from config import DATA_PATH, PROCESSED_DATA_PATH
import pickle
from scipy.integrate import simpson

# test set
EXCLUDED = [4, 6, 8, 20, 33, 49, 53, 63, 71, 72]

def load_subject(subject_id,path=DATA_PATH):
    """loads subject using their numeric id in the data folders"""
    return mne.io.read_raw_eeglab(path + '/derivatives/sub-' + str(subject_id).zfill(3)
                                    + '/eeg/sub-' + str(subject_id).zfill(3) + '_task-eyesclosed_eeg.set', preload = True,verbose='CRITICAL')

def subject_psd(raw,seg_length,fmin=0.5,fmax=45):
    """Computes the psd of each EEG channel for a given subject using Welch's method.

    Parameters
    ----------
    raw : 
        loaded RawEEGLAB data.
    seg_length : float
        length of each Welch segment in seconds. Determines frequency resolution. 
    fmin : float, optional
        Lower frequency of interest, by default 0.5.
    fmax : int, optional
        Upper frequency of interest, by default 45.

    Returns
    -------
    psd :
        psd of each EEG channel, stored in an mne Spectrum object.
    """        
    return raw.compute_psd(method='welch', fmin=fmin,fmax=fmax,n_fft=int(seg_length*raw.info['sfreq']),verbose=False)

def epochs_psd(raw,duration,overlap,seg_length,fmin=0.5,fmax=45,tmin=None,tmax=None):
    """Divides the EEG recording data into overlapping epochs for a given subject and 
    computes the psd of each EEG channel using Welch's method.

    Parameters
    ----------
    raw : 
        loaded RawEEGLAB data.
    duration : float
        Duration of each epoch in seconds.
    overlap : float
        overlap between epochs, in seconds.
    seg_length : float
        length of each Welch segment in seconds. Determines frequency resolution. 
    fmin : float, optional
        Lower frequency of interest, by default 0.5.
    fmax : int, optional
        Upper frequency of interest, by default 45.
    tmin : float, optional
        First time to include in seconds. Default value 'None' uses first time present in the data.
    tmax : float, optional
        Last time to include in seconds. Default value 'None' uses last time present in the data.

    Returns
    -------
    epochs_psds :
        psd of each EEG channel for each epoch, stored in an mne EpochsSpectrum object.
    """    
    epochs = mne.make_fixed_length_epochs(raw,duration=duration,preload=True,overlap=overlap,verbose=False)
    return epochs.compute_psd(method='welch', fmin=fmin,fmax=fmax,tmin=tmin,tmax=tmax,n_fft=int(seg_length*raw.info['sfreq']),verbose=False)

def load_data(duration,overlap,seg_length,fmin=0.5,fmax=45,classes={'A':1,'F':2,'C':0},path=DATA_PATH):
    """Loads all subjects from the specified classes, divides their EEG recordings into epochs, 
    computes the psd of each EEG channel using Welch's method, and then returns those psds with 
    the assigned class labels.

    Parameters
    ----------
    duration : float
        Duration of each epoch in seconds.
    overlap : float
        overlap between epochs, in seconds.
    seg_length : float
        length of each Welch segment in seconds. Determines frequency resolution. 
    fmin : float, optional
        Lower frequency of interest, by default 0.5.
    fmax : int, optional
        Upper frequency of interest, by default 45.
    classes : dict, optional
        Dictionary whose keys are the classes to include and values are the numeric labels. 
        By default {'A':1,'F':2,'C':0}.
    path : str, optional
        filepath to data folder. Defaults to PATH in config.py

    Returns
    -------
    subject_data : list[ndarray]
        List of arrays, each of shape (num_epochs) x (num_channels) x len(freqs), 
        with each array corresponding to a subject.
    freqs : ndarray
        Array of frequencies at which the psds are measured.
    targets : ndarray
        Numeric class labels for the subjects in subject_data. 
    """    
    subject_table = pd.read_csv(path + '/participants.tsv',sep='\t')
    target_labels = subject_table['Group']
    subject_data = []
    targets = []
    for subject_id in range(1,len(target_labels)+1):
        if target_labels.iloc[subject_id-1] not in classes:
            continue
        raw = load_subject(subject_id,path=path)
        epochs_psds = epochs_psd(raw,duration=duration,overlap=overlap,seg_length=seg_length,fmin=fmin,fmax=fmax)
        epochs_psds_array, freqs = epochs_psds.get_data(return_freqs=True)
        subject_data.append(epochs_psds_array)
        targets.append(classes[target_labels.iloc[subject_id-1]])
    return subject_data, freqs, np.array(targets)

def save_psds(subject_data,freqs,targets,filename,path=PROCESSED_DATA_PATH):
    """Pickles the psd data generated by load_data and saves it in the data processing folder"""
    with open(path + '/' + filename,'wb') as file:
        pickle.dump({'subject_data':subject_data,'freqs':freqs,'targets':targets},file)

def load_psds(filename,path=PROCESSED_DATA_PATH):
    """Loads pickled psd data from the data processing folder"""
    with open(path + '/' + filename,'rb') as file:
        psds = pickle.load(file)
    return psds['subject_data'], psds['freqs'], psds['targets']

def freq_ind(freqs,freq_bands):
    """returns list of indices in the freqs array corresponding to the frequencies in freq_bands"""
    indices = []
    for i in range(len(freq_bands)):
        indices.append(np.argmin(np.abs(freqs-freq_bands[i])))
    return indices

def absolute_band_power(psds,freqs,freq_bands,endpoints=freq_ind):
    """Computes absolute band power in each frequency band of each EEG channel of row in the psds array.

    Parameters
    ----------
    psds : ndarray
        Array of psds of shape (num_rows) x (num_channels) x len(freqs)
    freqs : ndarray
        1-D array of frequencies.
    freq_bands : array_like
        List of frequencies defining the boundaries of the frequency bands.
    endpoints : 
        Function used to match freq_bands to freqs.

    Returns
    -------
    abps: ndarray
        Array of absolute band power values of shape (num_rows) x (num_channels) x (len(freq_bands)-1)
    """    
    indices = endpoints(freqs,freq_bands)
    absolute_bands_list = []
    for i in range(len(indices)-1):
        absolute_bands_list.append(simpson(psds[...,indices[i]:indices[i+1]+1],freqs[indices[i]:indices[i+1]+1],axis=-1))
    return np.transpose(np.array(absolute_bands_list),(1,2,0))

def relative_band_power(psds,freqs,freq_bands,endpoints=freq_ind):
    """Computes relative band power in each frequency band of each EEG channel of row in the psds array.

    Parameters
    ----------
    psds : ndarray
        Array of psds of shape (num_rows) x (num_channels) x len(freqs).
    freqs : ndarray
        1-D array of frequencies.
    freq_bands : array_like
        List of frequencies defining the boundaries of the frequency bands.
    endpoints : 
        Function used to match freq_bands to freqs.

    Returns
    -------
    rbps: ndarray
        Array of relative band power values of shape (num_rows) x (num_channels) x (len(freq_bands)-1).
    """    
    indices = endpoints(freqs,freq_bands)
    total_power = np.expand_dims(simpson(psds[...,indices[0]:indices[-1]+1],freqs[indices[0]:indices[-1]+1],axis=-1),axis=-1)
    return np.divide(absolute_band_power(psds,freqs,freq_bands,endpoints=endpoints),total_power)






